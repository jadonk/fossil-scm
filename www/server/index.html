<div class='fossil-doc' data-title="How To Configure A Fossil Server">

<style type="text/css" nonce="$NONCE">
  p {
    margin-left: 4em;
    margin-right: 3em;
  }

  h2 {
    margin-left: 1em;
  }

  h3 {
    margin-left: 3em;
  }

  ol, ul {
    margin-left: 3em;
  }

  a#all {
    font-size: 90%;
    margin-left: 1em;
  }

  div#tutpick.show {
    max-height: 99em;
    transition: max-height 1000ms ease-in;
  }
  div#tutpick {
    max-height: 0;
    overflow: hidden;
  }

  th.fep {
    background-color: #e8e8e8;
    min-width: 3em;
    padding: 0.4em;
    white-space: nowrap;
  }

  th.host {
    background-color: #e8e8e8;
    padding: 0.4em;
    text-align: right;
  }

  td.doc {
    text-align: center;
  }
</style>


<h2>No Server Required</h2>

<p>Fossil does not require a central server, but <a
href="whyuseaserver.wiki">a server can be very useful</a>.</p>

<p>This article is a quick-reference guide for setting up your own
Fossil server, with links to more detailed instructions specific to
particular systems, should you want extra help.</p>


<h2 id="methods">Methods</h2>

<p>There are basically four ways to set up a Fossil server:</p>

<ol>
  <li>Socket listener:
      <a id="inetd"      href="any/inetd.md">inetd</a>,
      <a id="xinetd"     href="any/xinetd.md">xinetd</a>,
      <a id="stunnel"    href="any/stunnel.md">stunnel</a>...
  <li><a id="standalone" href="any/none.md">Stand-alone HTTP server</a>
  <li><a id="scgi"       href="any/scgi.md">SCGI</a>
  <li><a id="cgi"        href="any/cgi.md">CGI</a>
</ol>

<p>All of these methods can serve either a single repository or a
directory hierarchy containing many repositories with names ending in
"<tt>.fossil</tt>".</p>

<p>You are not restricted to using a single method. The same Fossil
repository can be served using two or more of the above techniques at
the same time. You can also migrate from one method to another to
accommodate changes in hosting providers or administrator
preferences.</p>


<h3>Socket Listener</h3>

<p>The idea behind the socket listener approach is that each incoming
HTTP request is relayed to a new instance of the <a
href="/help?cmd=http"><tt>fossil http</tt></a> command.  That command
reads the HTTP request from its standard input, handles the request, and
writes a complete and correct HTTP reply on standard output which is
then returned to the client.</p>


<h3>Stand-alone HTTP Server</h3>

<p>A stand-alone server uses the <a href="/help?cmd=server"><tt>fossil
server</tt></a> command to run a process that listens for incoming HTTP
requests on a socket and then dispatches a copy of itself to deal with
each incoming request.  A stand-alone server can talk directly with the
client, or the system can be configured with a reverse proxy in between
the client and Fossil.</p>


<h3>CGI and SCGI</h3>

<p>Fossil can also be run using CGI from ordinary web servers such as
Apache, <a href="windows/cgi.md">IIS</a>, <tt>lighttpd</tt>, or
<tt>althttpd</tt>. The Fossil server administrator places a <a
href="/help?cmd=cgi">short CGI script</a> in the web server's document
hierarchy, and when a client requests the appropriate URL, that script
runs Fossil to generate the responce.  CGI is a good choice for merging
Fossil into an existing web site. The Fossil <a
href="../selfhost.wiki">self-hosting repositories</a> are implemented
with CGI underneath <tt>althttpd</tt>.</p>

<p>For web servers such as nginx that do not support CGI, Fossil
supports SCGI, a protocol that gives most of the simplicity of CGI with
the efficiency of the stand-alone server option. With nginx, you use the
<a href="/help/server"><tt>fossil server --scgi</tt></a> command.</p>



<h2 id="matrix">Setup Tutorials</h2>

<p>We've broken the configuration for each method out into a series of
sub-articles. Some of these are generic, while others depend on
particular operating systems or front-end software:</p>

<div id="tutpick"></div>

<!-- Define alternative to JS tutorial picker below.  When updating this
     table, update "matrix" in the JS code below to match! -->
<noscript id="tutmatrix">
<table style="margin-left: 6em;">
    <tr>
        <th class="host">⇩ OS / Method ⇨</th>
        <th class="fep">none</th>
        <th class="fep">inetd</th>
        <th class="fep">stunnel</th>
        <th class="fep">CGI</th>
        <th class="fep">SCGI</th>
        <th class="fep">althttpd</th>
        <th class="fep">proxy</th>
        <th class="fep">service</th>
    </tr>

    <tr>
        <th class="host">Any</th>
        <td class="doc"><a href="any/none.md">✅</a></td>
        <td class="doc"><a href="any/inetd.md">✅</a></td>
        <td class="doc"><a href="any/stunnel.md">✅</a></td>
        <td class="doc"><a href="any/cgi.md">✅</a></td>
        <td class="doc"><a href="any/scgi.md">✅</a></td>
        <td class="doc"><a href="any/althttpd.md">✅</a></td>
        <td class="doc">❌</td>
        <td class="doc">❌</td>
    </tr>

    <tr>
        <th class="host">Debian/Ubuntu</th>
        <td class="doc"><a href="any/none.md">✅</a></td>
        <td class="doc"><a href="any/inetd.md">✅</a></td>
        <td class="doc"><a href="any/stunnel.md">✅</a></td>
        <td class="doc"><a href="any/cgi.md">✅</a></td>
        <td class="doc"><a href="any/scgi.md">✅</a></td>
        <td class="doc"><a href="any/althttpd.md">✅</a></td>
        <td class="doc"><a href="debian/nginx.md">✅</a></td>
        <td class="doc">❌</td>
    </tr>

    <tr>
        <th class="host">Windows</th>
        <td class="doc">❌</td>
        <td class="doc">❌</td>
        <td class="doc"><a href="windows/stunnel.md">✅</a></td>
        <td class="doc"><a href="windows/cgi.md">✅</a></td>
        <td class="doc">❌</td>
        <td class="doc">❌</td>
        <td class="doc"><a href="windows/iis.md">✅</a></td>
        <td class="doc"><a href="windows/service.md">✅</a></td>
    </tr>
</table>

<p>Where there is a check mark in the "<b>Any</b>" row, the method for that is
generic enough that it works across OSes that Fossil is known to work
on. The check marks below that usually just link to this generic
documentation.</p>

<p>The method in the "<b>proxy</b>" column is for the platform's default
web server configured as a <a
href="https://en.wikipedia.org/wiki/Reverse_proxy">reverse proxy</a> for
Fossil's built-in HTTP server: <a href="debian/nginx.md">nginx</a>, <a
href="windows/iis.md">IIS</a>, Apache, etc.</p>

<p>There are several widely-deployed socket listener schemes besides the
<tt>inetd</tt>, <tt>xinetd</tt>, and <tt>stunnel</tt> schemes with
documents linked above: Apple’s <tt>launchd</tt>, Linux’s
<tt>systemd</tt>, Solaris’ SMF, etc. We would welcome <a
href="contribute.wiki">contributions</a> to cover these as well. We also
welcome contributions to fill gaps (<font size="-2">❌</font>) in the table
above.  </p>
</noscript>


<h2 id="more">Further Details</h2>

<ul>
  <li><a id="chroot"   href="../chroot.md"     >The Server Chroot Jail</a>
  <li><a id="loadmgmt" href="../loadmgmt.md"   >Managing Server Load</a>
  <li><a id="tls"      href="../ssl.wiki"      >Securing a Repository with TLS</a>
  <li><a id="ext"      href="../serverext.wiki">CGI Server Extensions</a>
  <li><a id="about"    href="../aboutcgi.wiki" >How CGI Works In Fossil</a>
  <li><a id="sync"     href="../sync.wiki"     >The Fossil Sync Protocol</a>
</ul>

</div>

<script type="text/javascript" nonce="$NONCE">
  (function() {
    // Define data structure analog to <table> above.  Matrix elements
    // can have one of these constant values or a string for a one-off
    // custom value.  Values outside the <table> above go at the end of
    // the rows we define here.
    const YES = 1;  // host-specific doc provided
    const IFA = 2;  // inherit doc from "any"
    const NO  = 3;  // method invalid or undocumented for this host OS
    const methods = [
      "none", "inetd", "stunnel", "CGI", "SCGI", "althttpd", "proxy", "service"
    ];
    const matrix =     {
               "any OS": [ YES, YES, YES, YES, YES, YES, NO,      NO ],
     "Debian or Ubuntu": [ IFA, IFA, IFA, IFA, IFA, IFA, "nginx", NO ],
              "Windows": [ NO,  NO,  YES, YES, NO,  NO,  "IIS",   NO ],
    }
    const osNames = Object.keys(matrix).sort((e) => {
      return e.toLowerCase()
    }).map((longName, i) => {
      var shortName = longName.toLowerCase().split(' ')[0];
      return [ longName, shortName ];
    });
    const osNameMap = Object.fromEntries(osNames);
    //console.log("OS name map: " + JSON.stringify(osNameMap));
    
    // Build initial tutorial chooser HTML, and insert it into doc where
    // the static HTML <table> matrix normally goes.
    var html = '<p><b>I want to run Fossil on</b> <select id="os">';
    for (var os of osNames) {
      const  longName = os[0];
      const shortName = os[1];
      html += '<option name="' + shortName + '">' + longName + '</option>';
    }
    html += '</select> <b>underneath</b> <select id="fep"></select>'
    html += '<a id="all">SHOW ALL</a></p>';
    const picker = document.querySelector('div#tutpick');
    picker.innerHTML = html;
    picker.classList.add('show');

    // Slide noscript <table> in place of JS tutorial chooser on
    // "SHOW ALL" click.
    document.querySelector('a#all').addEventListener('click', () => {
      picker.classList.remove('show');
      picker.innerHTML = document.querySelector('#tutmatrix').innerHTML;
      setTimeout(() => {
        // Let doc update to set new height, so transition happens.
        picker.classList.add('show');
      }, 10);
    });

    // Attach event handlers to drop-downs.  Have to wait until the page
    // loads, else we'll get null back from querySelector(('select#foo')).
    window.addEventListener('load', () => {
      // Set up the FEP choice drop-down on initial page load and
      // update it when the OS choice drop-down changes.
      const osSel  = document.querySelector('select#os');
      const fepSel = document.querySelector('select#fep');
      function osClickHandler() {
        var osLong  = osSel.value;
        var osShort = osNameMap[osLong];

        var html = '<option>---</option>';
        matrix[osLong].forEach((choice, i) => {
          var mu;
          if (typeof(choice) === 'string') {
            mu = choice;
            choice = YES;
          }
          else {
            mu = methods[i];
          }
          const ml = mu.toLowerCase();

          if (choice != NO) {
            if (choice == YES) {
              html += '<option value="' + osShort + '/' + ml + '.md">';
            }
            else if (choice == IFA) {
              html += '<option value="any/' + ml + '.md">';
            }
            html += mu + '</option>';
          }
        });

        fepSel.innerHTML = html;
      }
      osSel.addEventListener('change', osClickHandler);
      osClickHandler();   // load fepSel initial content

      // Go to selected document when user changes FEP drop-down
      fepSel.addEventListener('change', () => {
        var doc = fepSel.value;
        if (doc) location.href = doc;
        // else it's the --- entry, either because we just reloaded the
        // <option> set or because the user re-selected it.
      });
    });
  })();
</script>
